#!/bin/sh
# ** (c) 2020 TosoBoso - start-stop and other cli for Jitsi-Meet in Docker container
# ** get lang, variables from lib and add functions, more variables, adjust script-dir when called by softlink
SCRIPT_DIR=$(dirname "$0")
[ -f "$SCRIPT_DIR"/lib  ] || SCRIPT_DIR=/var/packages/Jitsi-Meet/scripts
. "$SCRIPT_DIR"/lib
. "$SCRIPT_DIR"/common
LOGIN=$(whoami)
if [ "$LOGIN" != "root" ]
then
	MSG=$(MESSAGE_LANG "$SUDO_MODE")
	echo "$MSG"
	SUDO="sudo"
else
	SUDO=""
fi
# source cfg file, make it readable if not root
[ "$SUDO" = "" ] || sudo chmod 644 "$ETC_PATH"/.cfg
. "$ETC_PATH"/.cfg
[ "$SUDO" = "" ] || sudo chmod 640 "$ETC_PATH"/.cfg

MYSCRIPT=$(basename "$0")
case $1 in
    start)
        echo "Starting $CONTAINERS..."
		UPDATE_PUBLIC_IP
		# initial start after reset: start to get cfg, run real-ip, special settings restart
		if [ ! -e /etc/jitsi/web/nginx ] ; then
			START_CONTAINER
			NGINX_X_REAL_IP
			SPECIAL_SETTINGS
			STOP_CONTAINER
		fi
		UPDATE_CERT
		START_CONTAINER
		[ -f /etc/jitsi/prosody/.usr-created ] || CREATE_USERS
		# list nginx-error-log last entry
		WEB_ERR=$(EXEC_IN_CONTAINER web "tail -1 /var/log/nginx/error.log")
		[ -z "$WEB_ERR" ] || echo "Jitsi-Web last error: $WEB_ERR"
       ;;
    stop)
        echo "Stopping $CONTAINERS..."
		STOP_CONTAINER
        ;;
    status)
		for CONT in $IMGS_SHORT; do
			if ! $SUDO "$DOCKER_BIN" inspect "jitsi_$CONT" | grep -q "\"Status\": \"running\"," ; then
				echo "$CONT stopped"
				exit 1
			fi
		done
		# as jitsi-cli act more verbose with longer compose response time 
		if [ "$MYSCRIPT" = "jitsi-cli" ] ; then
	        echo "Running - fetching details..."
			STATUS_CONTAINER
		fi
		exit 0
        ;;
    log)
		case "$2" in
			web)
				SERVICE=jitsi-web
				;;
			prosody)
				SERVICE=jitsi-prosody
				;;
			jicofo)
				SERVICE=jitsi-jicofo
				;;
			jvb)
				SERVICE=jitsi-jvb
				;;
			pkg)
				if [ -t 1 ] ; then $SUDO chmod 666 "$LOG_FILE" ; fi
				MSG=$(tail -50 < "$LOG_FILE")
				if [ -t 1 ] ; then $SUDO chmod 666 "$LOG_FILE" ; fi
				echo "last 50 lines of $LOG_FILE:"
				echo "$MSG"
				exit 0
				;;
			rooms)
				echo "log from containers for rooms opened and joined will be implemented later.."
				exit 0
				;;
			*)
				echo "Need type of log: pkg, rooms, web, prosody, jicofo, jvb"
				exit 1
				;;
		esac
		CONTAINER_LOGS "$SERVICE"
        ;;
    reset)
		LOG_IF_BETA "running REMOVE_CONTAINER.."
		REMOVE_CONTAINER
		LOG_IF_BETA "running COMPOSE_CONTAINER.."
		COMPOSE_CONTAINER
		# in ajax gui mode do not run start sequence as it would time-out
		if [ ! -t 1 ] && [ "$2" != "bgmode" ] ; then
			echo "Now run ** $MYSCRIPT start **"
		else
			LOG_IF_BETA "running UPDATE_PUBLIC_IP.."
			UPDATE_PUBLIC_IP
			LOG_IF_BETA "running START_CONTAINER.."
			START_CONTAINER
			LOG_IF_BETA "running SPECIAL_SETTINGS.."
			SPECIAL_SETTINGS
			LOG_IF_BETA "running NGINX_X_REAL_IP, UPDATE_CERT.."
			NGINX_X_REAL_IP
			UPDATE_CERT
			START_CONTAINER
			CREATE_USERS
			WEB_ERR=$(EXEC_IN_CONTAINER web "tail -1 /var/log/nginx/error.log")
			[ -z "$WEB_ERR" ] || echo "Jitsi-Web last error: $WEB_ERR"
			MSG=$(MESSAGE_LANG "$RESET_IMAGES")
			LOG_MESSAGE "$MSG"
			if [ "$2" = "bgmode" ] ; then
				NOTIFY_MESSAGE "$MSG"
			fi
			LOG_IF_BETA "done.."
		fi
        ;;
    refresh)
		if [ -z "$2" ]; then
			MODE=img
			echo "defaulting refresh mode to: img (docker-image); also available: cfg (docker-yml and env) or all"
		else
			if [ "$2" != "img" ] && [ "$2" != "cfg" ] && [ "$2" != "all" ] ; then
				echo "need mode for refresh: img or cfg or all"
				exit 1
			fi
			MODE="$2"
		fi
		if [ "$MODE" != "img" ] ; then
			LOG_IF_BETA "running LOAD_REPO_CFG.."
			LOAD_REPO_CFG
			LOG_IF_BETA "running REFRESH_ENV.."
			REFRESH_ENV
		fi
		if [ "$MODE" != "cfg" ] ; then
			LOG_IF_BETA "running GET_DOCKER_UPDATE.."
			DOCKER_UPDATE=$(GET_DOCKER_UPDATE)
			SYNOPKG_DOCKER_UPDATE=$($SUDO /bin/get_key_value "$ETC_PATH"/.cfg SYNOPKG_DOCKER_UPDATE)
			# set docker_update or exit if up to date
			if [ "$DOCKER_UPDATE" = "$SYNOPKG_DOCKER_UPDATE" ] ; then
				echo "Docker Images are up to date: $DOCKER_UPDATE"
				exit 0
			else
				$SUDO sed -i -e "s~SYNOPKG_DOCKER_UPDATE=.*~SYNOPKG_DOCKER_UPDATE=${DOCKER_UPDATE}~" "$ETC_PATH"/.cfg
			fi
			LOG_IF_BETA "running REMOVE_CONTAINER/IMAGES,COMPOSE_CONTAINER and restart.."
			REMOVE_CONTAINER
			REMOVE_IMAGES
			COMPOSE_CONTAINER
			# in ajax gui mode do not run start sequence as it would time-out
			if [ ! -t 1 ] && [ "$2" != "bgmode" ] ; then
				echo "Now run ** $MYSCRIPT start **"
			else
				UPDATE_PUBLIC_IP
				START_CONTAINER
				SPECIAL_SETTINGS
				NGINX_X_REAL_IP
				UPDATE_CERT
				START_CONTAINER
				CREATE_USERS
				WEB_ERR=$(EXEC_IN_CONTAINER web "tail -1 /var/log/nginx/error.log")
				[ -z "$WEB_ERR" ] || echo "Jitsi-Web last error: $WEB_ERR"
				MSG=$(MESSAGE_LANG "$REFRESHED_IMAGES" "$IMAGES")
				LOG_MESSAGE "$MSG"
				if [ "$2" = "bgmode" ] ; then
					NOTIFY_MESSAGE "$MSG"
				fi
			fi
		fi
        ;;
    cmd-line)
		case "$2" in
			web)
				SERVICE=web
				;;
			prosody)
				SERVICE=prosody
				;;
			jicofo)
				SERVICE=jicofo
				;;
			jvb)
				SERVICE=jvb
				;;
			etherpad)
				SERVICE=etherpad
				;;
			*)
				echo "Need service for cmd-line: web, prosody, jicofo, jvb, etherpad"
				exit 1
				;;
		esac
		# command defaults to bash to get into container
		if [ -n "$3" ] ; then
			CMD="$3"
		else
			CMD="bash"
		fi
		EXEC_IN_CONTAINER "$SERVICE" "$CMD"
		;;
    add-usr)
		if [ $# -lt 3 ] ; then
			echo "Please provide user to add and password as parameters.."
			exit 1
		fi
		echo "adding user $2 via prosodyctl in prosody container.."
		EXEC_IN_CONTAINER prosody "prosodyctl --config /config/prosody.cfg.lua register $2 meet.jitsi $3"
		STORE_USER "$2" "$3"
		;;
    del-usr)
		if [ $# -lt 2 ] ; then
			echo "Please provide user to delete as parameters.."
			exit 1
		fi
		echo "deleting user $2 via prosodyctl in prosody container.."
		EXEC_IN_CONTAINER prosody "prosodyctl --config /config/prosody.cfg.lua deluser ${2}@meet.jitsi"
		REMOVE_USER "$2"
		;;
    *)
		echo "usage $MYSCRIPT start | stop | status | log | reset | refresh | add-usr | del-usr | cmd-line"
        exit 1
        ;;
esac